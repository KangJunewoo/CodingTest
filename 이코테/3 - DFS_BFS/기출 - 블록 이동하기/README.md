## 느낀점
### 상당히 많은 걸 배워간 문제
지도가 주어지고 최단거리 문제가 나왔을때, 일반적으로 그래프 탐색을 생각할 것이고 BFS가 떠오르는 것까지가 원래 나의 지식이었다. 하지만 그러한 탐색류의 문제를 만날 때마다 어려웠던 것은, 기본 코드는 v들이 다 정해져 있는 반면 이러한 문제는 탐색할 v가 정해져 있지 않아 만들어나가야 한다는 점이 문제였다. 이 문제는 그걸 어떻게 하는지 방향을 제시해주었다.
bfs의 과정은
* 첫 노드 인큐 + 방문처리
* 큐가 빌때까지
  * 큐에서 꺼내서
  * 인접한(다음에 갈 수 있는) v들 방문 ㄴ및 인큐
여기서 방문처리에 해당하는 리스트는 이미 v개수가 정해진 상황이라 건드리기 쉬웠다. 그러면 이와 같이 v개수가 정해지지 않은 상황에선ㄴ?  
=> 인큐 시 (v, cost)를 넣으면 된다.

코드 자체를 여러 번 곱씹어보고 체화해야겠다.

### 그 외의 팁들도 얻었다.
  * is_in_map 함수 대신 지도 늘리기 -> 인덱스 제한으로부터의 해방
  * 위치 상관안하고 싶을때 -> set 사용
  * 리스트 인자로 전달하기

등의 아이디어가 얻어갈 만 하다.
## notes
* 0은 빈칸 1은 벽
* 두 칸 모두 축이 될 수 있음.


## input
board : [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]
지도는 위와 같다.

## output
7
(1,1)에서 (5,5)까지 이동하는데 7초 걸림.

## strategy
구현하며 최소 시간을 찾는게 꽤 어렵긴 하네;;